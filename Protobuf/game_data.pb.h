// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game_data.proto

#ifndef PROTOBUF_game_5fdata_2eproto__INCLUDED
#define PROTOBUF_game_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rlbot {
namespace api {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_game_5fdata_2eproto();
void protobuf_InitDefaults_game_5fdata_2eproto();
void protobuf_AssignDesc_game_5fdata_2eproto();
void protobuf_ShutdownFile_game_5fdata_2eproto();

class BallInfo;
class BoostInfo;
class ControllerState;
class GameInfo;
class GameTickPacket;
class PlayerInfo;
class Rotator;
class ScoreInfo;
class Touch;
class Vector3;

// ===================================================================

class ControllerState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.ControllerState) */ {
 public:
  ControllerState();
  virtual ~ControllerState();

  ControllerState(const ControllerState& from);

  inline ControllerState& operator=(const ControllerState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerState& default_instance();

  static const ControllerState* internal_default_instance();

  void Swap(ControllerState* other);

  // implements Message ----------------------------------------------

  inline ControllerState* New() const { return New(NULL); }

  ControllerState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControllerState& from);
  void MergeFrom(const ControllerState& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ControllerState* other);
  void UnsafeMergeFrom(const ControllerState& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float throttle = 1;
  void clear_throttle();
  static const int kThrottleFieldNumber = 1;
  float throttle() const;
  void set_throttle(float value);

  // optional float steer = 2;
  void clear_steer();
  static const int kSteerFieldNumber = 2;
  float steer() const;
  void set_steer(float value);

  // optional float pitch = 3;
  void clear_pitch();
  static const int kPitchFieldNumber = 3;
  float pitch() const;
  void set_pitch(float value);

  // optional float yaw = 4;
  void clear_yaw();
  static const int kYawFieldNumber = 4;
  float yaw() const;
  void set_yaw(float value);

  // optional float roll = 5;
  void clear_roll();
  static const int kRollFieldNumber = 5;
  float roll() const;
  void set_roll(float value);

  // optional bool jump = 6;
  void clear_jump();
  static const int kJumpFieldNumber = 6;
  bool jump() const;
  void set_jump(bool value);

  // optional bool boost = 7;
  void clear_boost();
  static const int kBoostFieldNumber = 7;
  bool boost() const;
  void set_boost(bool value);

  // optional bool handbrake = 8;
  void clear_handbrake();
  static const int kHandbrakeFieldNumber = 8;
  bool handbrake() const;
  void set_handbrake(bool value);

  // @@protoc_insertion_point(class_scope:rlbot.api.ControllerState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float throttle_;
  float steer_;
  float pitch_;
  float yaw_;
  float roll_;
  bool jump_;
  bool boost_;
  bool handbrake_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ControllerState> ControllerState_default_instance_;

// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static const Vector3* internal_default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  inline Vector3* New() const { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector3* other);
  void UnsafeMergeFrom(const Vector3& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.Vector3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Vector3> Vector3_default_instance_;

// -------------------------------------------------------------------

class Rotator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.Rotator) */ {
 public:
  Rotator();
  virtual ~Rotator();

  Rotator(const Rotator& from);

  inline Rotator& operator=(const Rotator& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rotator& default_instance();

  static const Rotator* internal_default_instance();

  void Swap(Rotator* other);

  // implements Message ----------------------------------------------

  inline Rotator* New() const { return New(NULL); }

  Rotator* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rotator& from);
  void MergeFrom(const Rotator& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rotator* other);
  void UnsafeMergeFrom(const Rotator& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float pitch = 1;
  void clear_pitch();
  static const int kPitchFieldNumber = 1;
  float pitch() const;
  void set_pitch(float value);

  // optional float yaw = 2;
  void clear_yaw();
  static const int kYawFieldNumber = 2;
  float yaw() const;
  void set_yaw(float value);

  // optional float roll = 3;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  float roll() const;
  void set_roll(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.Rotator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float pitch_;
  float yaw_;
  float roll_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Rotator> Rotator_default_instance_;

// -------------------------------------------------------------------

class Touch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.Touch) */ {
 public:
  Touch();
  virtual ~Touch();

  Touch(const Touch& from);

  inline Touch& operator=(const Touch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Touch& default_instance();

  static const Touch* internal_default_instance();

  void Swap(Touch* other);

  // implements Message ----------------------------------------------

  inline Touch* New() const { return New(NULL); }

  Touch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Touch& from);
  void MergeFrom(const Touch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Touch* other);
  void UnsafeMergeFrom(const Touch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string player_name = 1;
  void clear_player_name();
  static const int kPlayerNameFieldNumber = 1;
  const ::std::string& player_name() const;
  void set_player_name(const ::std::string& value);
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  ::std::string* mutable_player_name();
  ::std::string* release_player_name();
  void set_allocated_player_name(::std::string* player_name);

  // optional float game_seconds = 2;
  void clear_game_seconds();
  static const int kGameSecondsFieldNumber = 2;
  float game_seconds() const;
  void set_game_seconds(float value);

  // optional .rlbot.api.Vector3 location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* mutable_location();
  ::rlbot::api::Vector3* release_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // optional .rlbot.api.Vector3 normal = 4;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 4;
  const ::rlbot::api::Vector3& normal() const;
  ::rlbot::api::Vector3* mutable_normal();
  ::rlbot::api::Vector3* release_normal();
  void set_allocated_normal(::rlbot::api::Vector3* normal);

  // @@protoc_insertion_point(class_scope:rlbot.api.Touch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr player_name_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Vector3* normal_;
  float game_seconds_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Touch> Touch_default_instance_;

// -------------------------------------------------------------------

class ScoreInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.ScoreInfo) */ {
 public:
  ScoreInfo();
  virtual ~ScoreInfo();

  ScoreInfo(const ScoreInfo& from);

  inline ScoreInfo& operator=(const ScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreInfo& default_instance();

  static const ScoreInfo* internal_default_instance();

  void Swap(ScoreInfo* other);

  // implements Message ----------------------------------------------

  inline ScoreInfo* New() const { return New(NULL); }

  ScoreInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreInfo& from);
  void MergeFrom(const ScoreInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScoreInfo* other);
  void UnsafeMergeFrom(const ScoreInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 score = 1;
  void clear_score();
  static const int kScoreFieldNumber = 1;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // optional int32 goals = 2;
  void clear_goals();
  static const int kGoalsFieldNumber = 2;
  ::google::protobuf::int32 goals() const;
  void set_goals(::google::protobuf::int32 value);

  // optional int32 own_goals = 3;
  void clear_own_goals();
  static const int kOwnGoalsFieldNumber = 3;
  ::google::protobuf::int32 own_goals() const;
  void set_own_goals(::google::protobuf::int32 value);

  // optional int32 assists = 4;
  void clear_assists();
  static const int kAssistsFieldNumber = 4;
  ::google::protobuf::int32 assists() const;
  void set_assists(::google::protobuf::int32 value);

  // optional int32 saves = 5;
  void clear_saves();
  static const int kSavesFieldNumber = 5;
  ::google::protobuf::int32 saves() const;
  void set_saves(::google::protobuf::int32 value);

  // optional int32 shots = 6;
  void clear_shots();
  static const int kShotsFieldNumber = 6;
  ::google::protobuf::int32 shots() const;
  void set_shots(::google::protobuf::int32 value);

  // optional int32 demolitions = 7;
  void clear_demolitions();
  static const int kDemolitionsFieldNumber = 7;
  ::google::protobuf::int32 demolitions() const;
  void set_demolitions(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.ScoreInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 goals_;
  ::google::protobuf::int32 own_goals_;
  ::google::protobuf::int32 assists_;
  ::google::protobuf::int32 saves_;
  ::google::protobuf::int32 shots_;
  ::google::protobuf::int32 demolitions_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ScoreInfo> ScoreInfo_default_instance_;

// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  static const PlayerInfo* internal_default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const { return New(NULL); }

  PlayerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfo* other);
  void UnsafeMergeFrom(const PlayerInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rlbot.api.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* mutable_location();
  ::rlbot::api::Vector3* release_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // optional .rlbot.api.Rotator rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::rlbot::api::Rotator& rotation() const;
  ::rlbot::api::Rotator* mutable_rotation();
  ::rlbot::api::Rotator* release_rotation();
  void set_allocated_rotation(::rlbot::api::Rotator* rotation);

  // optional .rlbot.api.Vector3 velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  const ::rlbot::api::Vector3& velocity() const;
  ::rlbot::api::Vector3* mutable_velocity();
  ::rlbot::api::Vector3* release_velocity();
  void set_allocated_velocity(::rlbot::api::Vector3* velocity);

  // optional .rlbot.api.Vector3 angular_velocity = 4;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 4;
  const ::rlbot::api::Vector3& angular_velocity() const;
  ::rlbot::api::Vector3* mutable_angular_velocity();
  ::rlbot::api::Vector3* release_angular_velocity();
  void set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity);

  // optional .rlbot.api.ScoreInfo score_info = 5;
  bool has_score_info() const;
  void clear_score_info();
  static const int kScoreInfoFieldNumber = 5;
  const ::rlbot::api::ScoreInfo& score_info() const;
  ::rlbot::api::ScoreInfo* mutable_score_info();
  ::rlbot::api::ScoreInfo* release_score_info();
  void set_allocated_score_info(::rlbot::api::ScoreInfo* score_info);

  // optional bool is_demolished = 6;
  void clear_is_demolished();
  static const int kIsDemolishedFieldNumber = 6;
  bool is_demolished() const;
  void set_is_demolished(bool value);

  // optional bool is_midair = 7;
  void clear_is_midair();
  static const int kIsMidairFieldNumber = 7;
  bool is_midair() const;
  void set_is_midair(bool value);

  // optional bool is_supersonic = 8;
  void clear_is_supersonic();
  static const int kIsSupersonicFieldNumber = 8;
  bool is_supersonic() const;
  void set_is_supersonic(bool value);

  // optional bool is_bot = 9;
  void clear_is_bot();
  static const int kIsBotFieldNumber = 9;
  bool is_bot() const;
  void set_is_bot(bool value);

  // optional bool jumped = 10;
  void clear_jumped();
  static const int kJumpedFieldNumber = 10;
  bool jumped() const;
  void set_jumped(bool value);

  // optional bool double_jumped = 11;
  void clear_double_jumped();
  static const int kDoubleJumpedFieldNumber = 11;
  bool double_jumped() const;
  void set_double_jumped(bool value);

  // optional string name = 12;
  void clear_name();
  static const int kNameFieldNumber = 12;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 team = 13;
  void clear_team();
  static const int kTeamFieldNumber = 13;
  ::google::protobuf::int32 team() const;
  void set_team(::google::protobuf::int32 value);

  // optional int32 boost = 14;
  void clear_boost();
  static const int kBoostFieldNumber = 14;
  ::google::protobuf::int32 boost() const;
  void set_boost(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.PlayerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Rotator* rotation_;
  ::rlbot::api::Vector3* velocity_;
  ::rlbot::api::Vector3* angular_velocity_;
  ::rlbot::api::ScoreInfo* score_info_;
  bool is_demolished_;
  bool is_midair_;
  bool is_supersonic_;
  bool is_bot_;
  bool jumped_;
  bool double_jumped_;
  ::google::protobuf::int32 team_;
  ::google::protobuf::int32 boost_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PlayerInfo> PlayerInfo_default_instance_;

// -------------------------------------------------------------------

class BallInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.BallInfo) */ {
 public:
  BallInfo();
  virtual ~BallInfo();

  BallInfo(const BallInfo& from);

  inline BallInfo& operator=(const BallInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallInfo& default_instance();

  static const BallInfo* internal_default_instance();

  void Swap(BallInfo* other);

  // implements Message ----------------------------------------------

  inline BallInfo* New() const { return New(NULL); }

  BallInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallInfo& from);
  void MergeFrom(const BallInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BallInfo* other);
  void UnsafeMergeFrom(const BallInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rlbot.api.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* mutable_location();
  ::rlbot::api::Vector3* release_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // optional .rlbot.api.Rotator rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::rlbot::api::Rotator& rotation() const;
  ::rlbot::api::Rotator* mutable_rotation();
  ::rlbot::api::Rotator* release_rotation();
  void set_allocated_rotation(::rlbot::api::Rotator* rotation);

  // optional .rlbot.api.Vector3 velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  const ::rlbot::api::Vector3& velocity() const;
  ::rlbot::api::Vector3* mutable_velocity();
  ::rlbot::api::Vector3* release_velocity();
  void set_allocated_velocity(::rlbot::api::Vector3* velocity);

  // optional .rlbot.api.Vector3 angular_velocity = 4;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 4;
  const ::rlbot::api::Vector3& angular_velocity() const;
  ::rlbot::api::Vector3* mutable_angular_velocity();
  ::rlbot::api::Vector3* release_angular_velocity();
  void set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity);

  // optional .rlbot.api.Vector3 acceleration = 5;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 5;
  const ::rlbot::api::Vector3& acceleration() const;
  ::rlbot::api::Vector3* mutable_acceleration();
  ::rlbot::api::Vector3* release_acceleration();
  void set_allocated_acceleration(::rlbot::api::Vector3* acceleration);

  // optional .rlbot.api.Touch latest_touch = 6;
  bool has_latest_touch() const;
  void clear_latest_touch();
  static const int kLatestTouchFieldNumber = 6;
  const ::rlbot::api::Touch& latest_touch() const;
  ::rlbot::api::Touch* mutable_latest_touch();
  ::rlbot::api::Touch* release_latest_touch();
  void set_allocated_latest_touch(::rlbot::api::Touch* latest_touch);

  // @@protoc_insertion_point(class_scope:rlbot.api.BallInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Rotator* rotation_;
  ::rlbot::api::Vector3* velocity_;
  ::rlbot::api::Vector3* angular_velocity_;
  ::rlbot::api::Vector3* acceleration_;
  ::rlbot::api::Touch* latest_touch_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BallInfo> BallInfo_default_instance_;

// -------------------------------------------------------------------

class BoostInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.BoostInfo) */ {
 public:
  BoostInfo();
  virtual ~BoostInfo();

  BoostInfo(const BoostInfo& from);

  inline BoostInfo& operator=(const BoostInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoostInfo& default_instance();

  static const BoostInfo* internal_default_instance();

  void Swap(BoostInfo* other);

  // implements Message ----------------------------------------------

  inline BoostInfo* New() const { return New(NULL); }

  BoostInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoostInfo& from);
  void MergeFrom(const BoostInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoostInfo* other);
  void UnsafeMergeFrom(const BoostInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rlbot.api.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* mutable_location();
  ::rlbot::api::Vector3* release_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // optional bool is_active = 2;
  void clear_is_active();
  static const int kIsActiveFieldNumber = 2;
  bool is_active() const;
  void set_is_active(bool value);

  // optional float timer = 3;
  void clear_timer();
  static const int kTimerFieldNumber = 3;
  float timer() const;
  void set_timer(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.BoostInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rlbot::api::Vector3* location_;
  bool is_active_;
  float timer_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BoostInfo> BoostInfo_default_instance_;

// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  static const GameInfo* internal_default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  inline GameInfo* New() const { return New(NULL); }

  GameInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameInfo* other);
  void UnsafeMergeFrom(const GameInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float seconds_elapsed = 1;
  void clear_seconds_elapsed();
  static const int kSecondsElapsedFieldNumber = 1;
  float seconds_elapsed() const;
  void set_seconds_elapsed(float value);

  // optional float game_time_remaining = 2;
  void clear_game_time_remaining();
  static const int kGameTimeRemainingFieldNumber = 2;
  float game_time_remaining() const;
  void set_game_time_remaining(float value);

  // optional bool is_overtime = 3;
  void clear_is_overtime();
  static const int kIsOvertimeFieldNumber = 3;
  bool is_overtime() const;
  void set_is_overtime(bool value);

  // optional bool is_unlimited_time = 4;
  void clear_is_unlimited_time();
  static const int kIsUnlimitedTimeFieldNumber = 4;
  bool is_unlimited_time() const;
  void set_is_unlimited_time(bool value);

  // optional bool is_round_active = 5;
  void clear_is_round_active();
  static const int kIsRoundActiveFieldNumber = 5;
  bool is_round_active() const;
  void set_is_round_active(bool value);

  // optional bool is_kickoff_pause = 6;
  void clear_is_kickoff_pause();
  static const int kIsKickoffPauseFieldNumber = 6;
  bool is_kickoff_pause() const;
  void set_is_kickoff_pause(bool value);

  // optional bool is_match_ended = 7;
  void clear_is_match_ended();
  static const int kIsMatchEndedFieldNumber = 7;
  bool is_match_ended() const;
  void set_is_match_ended(bool value);

  // @@protoc_insertion_point(class_scope:rlbot.api.GameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float seconds_elapsed_;
  float game_time_remaining_;
  bool is_overtime_;
  bool is_unlimited_time_;
  bool is_round_active_;
  bool is_kickoff_pause_;
  bool is_match_ended_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GameInfo> GameInfo_default_instance_;

// -------------------------------------------------------------------

class GameTickPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.GameTickPacket) */ {
 public:
  GameTickPacket();
  virtual ~GameTickPacket();

  GameTickPacket(const GameTickPacket& from);

  inline GameTickPacket& operator=(const GameTickPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameTickPacket& default_instance();

  static const GameTickPacket* internal_default_instance();

  void Swap(GameTickPacket* other);

  // implements Message ----------------------------------------------

  inline GameTickPacket* New() const { return New(NULL); }

  GameTickPacket* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameTickPacket& from);
  void MergeFrom(const GameTickPacket& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameTickPacket* other);
  void UnsafeMergeFrom(const GameTickPacket& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rlbot.api.PlayerInfo players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::rlbot::api::PlayerInfo& players(int index) const;
  ::rlbot::api::PlayerInfo* mutable_players(int index);
  ::rlbot::api::PlayerInfo* add_players();
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >&
      players() const;

  // optional int32 player_index = 2;
  void clear_player_index();
  static const int kPlayerIndexFieldNumber = 2;
  ::google::protobuf::int32 player_index() const;
  void set_player_index(::google::protobuf::int32 value);

  // repeated .rlbot.api.BoostInfo boost_pads = 3;
  int boost_pads_size() const;
  void clear_boost_pads();
  static const int kBoostPadsFieldNumber = 3;
  const ::rlbot::api::BoostInfo& boost_pads(int index) const;
  ::rlbot::api::BoostInfo* mutable_boost_pads(int index);
  ::rlbot::api::BoostInfo* add_boost_pads();
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >*
      mutable_boost_pads();
  const ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >&
      boost_pads() const;

  // optional .rlbot.api.BallInfo ball = 4;
  bool has_ball() const;
  void clear_ball();
  static const int kBallFieldNumber = 4;
  const ::rlbot::api::BallInfo& ball() const;
  ::rlbot::api::BallInfo* mutable_ball();
  ::rlbot::api::BallInfo* release_ball();
  void set_allocated_ball(::rlbot::api::BallInfo* ball);

  // optional .rlbot.api.GameInfo game_info = 5;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 5;
  const ::rlbot::api::GameInfo& game_info() const;
  ::rlbot::api::GameInfo* mutable_game_info();
  ::rlbot::api::GameInfo* release_game_info();
  void set_allocated_game_info(::rlbot::api::GameInfo* game_info);

  // @@protoc_insertion_point(class_scope:rlbot.api.GameTickPacket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo > players_;
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo > boost_pads_;
  ::rlbot::api::BallInfo* ball_;
  ::rlbot::api::GameInfo* game_info_;
  ::google::protobuf::int32 player_index_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_game_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_game_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GameTickPacket> GameTickPacket_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ControllerState

// optional float throttle = 1;
inline void ControllerState::clear_throttle() {
  throttle_ = 0;
}
inline float ControllerState::throttle() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.throttle)
  return throttle_;
}
inline void ControllerState::set_throttle(float value) {
  
  throttle_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.throttle)
}

// optional float steer = 2;
inline void ControllerState::clear_steer() {
  steer_ = 0;
}
inline float ControllerState::steer() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.steer)
  return steer_;
}
inline void ControllerState::set_steer(float value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.steer)
}

// optional float pitch = 3;
inline void ControllerState::clear_pitch() {
  pitch_ = 0;
}
inline float ControllerState::pitch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.pitch)
  return pitch_;
}
inline void ControllerState::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.pitch)
}

// optional float yaw = 4;
inline void ControllerState::clear_yaw() {
  yaw_ = 0;
}
inline float ControllerState::yaw() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.yaw)
  return yaw_;
}
inline void ControllerState::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.yaw)
}

// optional float roll = 5;
inline void ControllerState::clear_roll() {
  roll_ = 0;
}
inline float ControllerState::roll() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.roll)
  return roll_;
}
inline void ControllerState::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.roll)
}

// optional bool jump = 6;
inline void ControllerState::clear_jump() {
  jump_ = false;
}
inline bool ControllerState::jump() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.jump)
  return jump_;
}
inline void ControllerState::set_jump(bool value) {
  
  jump_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.jump)
}

// optional bool boost = 7;
inline void ControllerState::clear_boost() {
  boost_ = false;
}
inline bool ControllerState::boost() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.boost)
  return boost_;
}
inline void ControllerState::set_boost(bool value) {
  
  boost_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.boost)
}

// optional bool handbrake = 8;
inline void ControllerState::clear_handbrake() {
  handbrake_ = false;
}
inline bool ControllerState::handbrake() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.handbrake)
  return handbrake_;
}
inline void ControllerState::set_handbrake(bool value) {
  
  handbrake_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.handbrake)
}

inline const ControllerState* ControllerState::internal_default_instance() {
  return &ControllerState_default_instance_.get();
}
// -------------------------------------------------------------------

// Vector3

// optional float x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.x)
}

// optional float y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.y)
}

// optional float z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.z)
}

inline const Vector3* Vector3::internal_default_instance() {
  return &Vector3_default_instance_.get();
}
// -------------------------------------------------------------------

// Rotator

// optional float pitch = 1;
inline void Rotator::clear_pitch() {
  pitch_ = 0;
}
inline float Rotator::pitch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.pitch)
  return pitch_;
}
inline void Rotator::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.pitch)
}

// optional float yaw = 2;
inline void Rotator::clear_yaw() {
  yaw_ = 0;
}
inline float Rotator::yaw() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.yaw)
  return yaw_;
}
inline void Rotator::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.yaw)
}

// optional float roll = 3;
inline void Rotator::clear_roll() {
  roll_ = 0;
}
inline float Rotator::roll() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.roll)
  return roll_;
}
inline void Rotator::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.roll)
}

inline const Rotator* Rotator::internal_default_instance() {
  return &Rotator_default_instance_.get();
}
// -------------------------------------------------------------------

// Touch

// optional string player_name = 1;
inline void Touch::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Touch::player_name() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.player_name)
  return player_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Touch::set_player_name(const ::std::string& value) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rlbot.api.Touch.player_name)
}
inline void Touch::set_player_name(const char* value) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rlbot.api.Touch.player_name)
}
inline void Touch::set_player_name(const char* value, size_t size) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rlbot.api.Touch.player_name)
}
inline ::std::string* Touch::mutable_player_name() {
  
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.player_name)
  return player_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Touch::release_player_name() {
  // @@protoc_insertion_point(field_release:rlbot.api.Touch.player_name)
  
  return player_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Touch::set_allocated_player_name(::std::string* player_name) {
  if (player_name != NULL) {
    
  } else {
    
  }
  player_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.player_name)
}

// optional float game_seconds = 2;
inline void Touch::clear_game_seconds() {
  game_seconds_ = 0;
}
inline float Touch::game_seconds() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.game_seconds)
  return game_seconds_;
}
inline void Touch::set_game_seconds(float value) {
  
  game_seconds_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Touch.game_seconds)
}

// optional .rlbot.api.Vector3 location = 3;
inline bool Touch::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Touch::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& Touch::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.location)
  return location_ != NULL ? *location_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* Touch::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.location)
  return location_;
}
inline ::rlbot::api::Vector3* Touch::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.Touch.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Touch::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.location)
}

// optional .rlbot.api.Vector3 normal = 4;
inline bool Touch::has_normal() const {
  return this != internal_default_instance() && normal_ != NULL;
}
inline void Touch::clear_normal() {
  if (GetArenaNoVirtual() == NULL && normal_ != NULL) delete normal_;
  normal_ = NULL;
}
inline const ::rlbot::api::Vector3& Touch::normal() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.normal)
  return normal_ != NULL ? *normal_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* Touch::mutable_normal() {
  
  if (normal_ == NULL) {
    normal_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.normal)
  return normal_;
}
inline ::rlbot::api::Vector3* Touch::release_normal() {
  // @@protoc_insertion_point(field_release:rlbot.api.Touch.normal)
  
  ::rlbot::api::Vector3* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void Touch::set_allocated_normal(::rlbot::api::Vector3* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.normal)
}

inline const Touch* Touch::internal_default_instance() {
  return &Touch_default_instance_.get();
}
// -------------------------------------------------------------------

// ScoreInfo

// optional int32 score = 1;
inline void ScoreInfo::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::score() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.score)
  return score_;
}
inline void ScoreInfo::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.score)
}

// optional int32 goals = 2;
inline void ScoreInfo::clear_goals() {
  goals_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::goals() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.goals)
  return goals_;
}
inline void ScoreInfo::set_goals(::google::protobuf::int32 value) {
  
  goals_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.goals)
}

// optional int32 own_goals = 3;
inline void ScoreInfo::clear_own_goals() {
  own_goals_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::own_goals() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.own_goals)
  return own_goals_;
}
inline void ScoreInfo::set_own_goals(::google::protobuf::int32 value) {
  
  own_goals_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.own_goals)
}

// optional int32 assists = 4;
inline void ScoreInfo::clear_assists() {
  assists_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::assists() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.assists)
  return assists_;
}
inline void ScoreInfo::set_assists(::google::protobuf::int32 value) {
  
  assists_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.assists)
}

// optional int32 saves = 5;
inline void ScoreInfo::clear_saves() {
  saves_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::saves() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.saves)
  return saves_;
}
inline void ScoreInfo::set_saves(::google::protobuf::int32 value) {
  
  saves_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.saves)
}

// optional int32 shots = 6;
inline void ScoreInfo::clear_shots() {
  shots_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::shots() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.shots)
  return shots_;
}
inline void ScoreInfo::set_shots(::google::protobuf::int32 value) {
  
  shots_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.shots)
}

// optional int32 demolitions = 7;
inline void ScoreInfo::clear_demolitions() {
  demolitions_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::demolitions() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.demolitions)
  return demolitions_;
}
inline void ScoreInfo::set_demolitions(::google::protobuf::int32 value) {
  
  demolitions_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.demolitions)
}

inline const ScoreInfo* ScoreInfo::internal_default_instance() {
  return &ScoreInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// PlayerInfo

// optional .rlbot.api.Vector3 location = 1;
inline bool PlayerInfo::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void PlayerInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& PlayerInfo::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.location)
  return location_ != NULL ? *location_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.location)
  return location_;
}
inline ::rlbot::api::Vector3* PlayerInfo::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.location)
}

// optional .rlbot.api.Rotator rotation = 2;
inline bool PlayerInfo::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void PlayerInfo::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) delete rotation_;
  rotation_ = NULL;
}
inline const ::rlbot::api::Rotator& PlayerInfo::rotation() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.rotation)
  return rotation_ != NULL ? *rotation_
                         : *::rlbot::api::Rotator::internal_default_instance();
}
inline ::rlbot::api::Rotator* PlayerInfo::mutable_rotation() {
  
  if (rotation_ == NULL) {
    rotation_ = new ::rlbot::api::Rotator;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.rotation)
  return rotation_;
}
inline ::rlbot::api::Rotator* PlayerInfo::release_rotation() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.rotation)
  
  ::rlbot::api::Rotator* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_rotation(::rlbot::api::Rotator* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.rotation)
}

// optional .rlbot.api.Vector3 velocity = 3;
inline bool PlayerInfo::has_velocity() const {
  return this != internal_default_instance() && velocity_ != NULL;
}
inline void PlayerInfo::clear_velocity() {
  if (GetArenaNoVirtual() == NULL && velocity_ != NULL) delete velocity_;
  velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& PlayerInfo::velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.velocity)
  return velocity_ != NULL ? *velocity_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_velocity() {
  
  if (velocity_ == NULL) {
    velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.velocity)
  return velocity_;
}
inline ::rlbot::api::Vector3* PlayerInfo::release_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.velocity)
  
  ::rlbot::api::Vector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_velocity(::rlbot::api::Vector3* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.velocity)
}

// optional .rlbot.api.Vector3 angular_velocity = 4;
inline bool PlayerInfo::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != NULL;
}
inline void PlayerInfo::clear_angular_velocity() {
  if (GetArenaNoVirtual() == NULL && angular_velocity_ != NULL) delete angular_velocity_;
  angular_velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& PlayerInfo::angular_velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.angular_velocity)
  return angular_velocity_;
}
inline ::rlbot::api::Vector3* PlayerInfo::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.angular_velocity)
  
  ::rlbot::api::Vector3* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.angular_velocity)
}

// optional .rlbot.api.ScoreInfo score_info = 5;
inline bool PlayerInfo::has_score_info() const {
  return this != internal_default_instance() && score_info_ != NULL;
}
inline void PlayerInfo::clear_score_info() {
  if (GetArenaNoVirtual() == NULL && score_info_ != NULL) delete score_info_;
  score_info_ = NULL;
}
inline const ::rlbot::api::ScoreInfo& PlayerInfo::score_info() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.score_info)
  return score_info_ != NULL ? *score_info_
                         : *::rlbot::api::ScoreInfo::internal_default_instance();
}
inline ::rlbot::api::ScoreInfo* PlayerInfo::mutable_score_info() {
  
  if (score_info_ == NULL) {
    score_info_ = new ::rlbot::api::ScoreInfo;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.score_info)
  return score_info_;
}
inline ::rlbot::api::ScoreInfo* PlayerInfo::release_score_info() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.score_info)
  
  ::rlbot::api::ScoreInfo* temp = score_info_;
  score_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_score_info(::rlbot::api::ScoreInfo* score_info) {
  delete score_info_;
  score_info_ = score_info;
  if (score_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.score_info)
}

// optional bool is_demolished = 6;
inline void PlayerInfo::clear_is_demolished() {
  is_demolished_ = false;
}
inline bool PlayerInfo::is_demolished() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_demolished)
  return is_demolished_;
}
inline void PlayerInfo::set_is_demolished(bool value) {
  
  is_demolished_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_demolished)
}

// optional bool is_midair = 7;
inline void PlayerInfo::clear_is_midair() {
  is_midair_ = false;
}
inline bool PlayerInfo::is_midair() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_midair)
  return is_midair_;
}
inline void PlayerInfo::set_is_midair(bool value) {
  
  is_midair_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_midair)
}

// optional bool is_supersonic = 8;
inline void PlayerInfo::clear_is_supersonic() {
  is_supersonic_ = false;
}
inline bool PlayerInfo::is_supersonic() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_supersonic)
  return is_supersonic_;
}
inline void PlayerInfo::set_is_supersonic(bool value) {
  
  is_supersonic_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_supersonic)
}

// optional bool is_bot = 9;
inline void PlayerInfo::clear_is_bot() {
  is_bot_ = false;
}
inline bool PlayerInfo::is_bot() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_bot)
  return is_bot_;
}
inline void PlayerInfo::set_is_bot(bool value) {
  
  is_bot_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_bot)
}

// optional bool jumped = 10;
inline void PlayerInfo::clear_jumped() {
  jumped_ = false;
}
inline bool PlayerInfo::jumped() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.jumped)
  return jumped_;
}
inline void PlayerInfo::set_jumped(bool value) {
  
  jumped_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.jumped)
}

// optional bool double_jumped = 11;
inline void PlayerInfo::clear_double_jumped() {
  double_jumped_ = false;
}
inline bool PlayerInfo::double_jumped() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.double_jumped)
  return double_jumped_;
}
inline void PlayerInfo::set_double_jumped(bool value) {
  
  double_jumped_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.double_jumped)
}

// optional string name = 12;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rlbot.api.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rlbot.api.PlayerInfo.name)
}
inline ::std::string* PlayerInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.name)
}

// optional int32 team = 13;
inline void PlayerInfo::clear_team() {
  team_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::team() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.team)
  return team_;
}
inline void PlayerInfo::set_team(::google::protobuf::int32 value) {
  
  team_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.team)
}

// optional int32 boost = 14;
inline void PlayerInfo::clear_boost() {
  boost_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::boost() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.boost)
  return boost_;
}
inline void PlayerInfo::set_boost(::google::protobuf::int32 value) {
  
  boost_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.boost)
}

inline const PlayerInfo* PlayerInfo::internal_default_instance() {
  return &PlayerInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// BallInfo

// optional .rlbot.api.Vector3 location = 1;
inline bool BallInfo::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void BallInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.location)
  return location_ != NULL ? *location_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* BallInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.location)
  return location_;
}
inline ::rlbot::api::Vector3* BallInfo::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.location)
}

// optional .rlbot.api.Rotator rotation = 2;
inline bool BallInfo::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void BallInfo::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) delete rotation_;
  rotation_ = NULL;
}
inline const ::rlbot::api::Rotator& BallInfo::rotation() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.rotation)
  return rotation_ != NULL ? *rotation_
                         : *::rlbot::api::Rotator::internal_default_instance();
}
inline ::rlbot::api::Rotator* BallInfo::mutable_rotation() {
  
  if (rotation_ == NULL) {
    rotation_ = new ::rlbot::api::Rotator;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.rotation)
  return rotation_;
}
inline ::rlbot::api::Rotator* BallInfo::release_rotation() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.rotation)
  
  ::rlbot::api::Rotator* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_rotation(::rlbot::api::Rotator* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.rotation)
}

// optional .rlbot.api.Vector3 velocity = 3;
inline bool BallInfo::has_velocity() const {
  return this != internal_default_instance() && velocity_ != NULL;
}
inline void BallInfo::clear_velocity() {
  if (GetArenaNoVirtual() == NULL && velocity_ != NULL) delete velocity_;
  velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.velocity)
  return velocity_ != NULL ? *velocity_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* BallInfo::mutable_velocity() {
  
  if (velocity_ == NULL) {
    velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.velocity)
  return velocity_;
}
inline ::rlbot::api::Vector3* BallInfo::release_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.velocity)
  
  ::rlbot::api::Vector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_velocity(::rlbot::api::Vector3* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.velocity)
}

// optional .rlbot.api.Vector3 angular_velocity = 4;
inline bool BallInfo::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != NULL;
}
inline void BallInfo::clear_angular_velocity() {
  if (GetArenaNoVirtual() == NULL && angular_velocity_ != NULL) delete angular_velocity_;
  angular_velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::angular_velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* BallInfo::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.angular_velocity)
  return angular_velocity_;
}
inline ::rlbot::api::Vector3* BallInfo::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.angular_velocity)
  
  ::rlbot::api::Vector3* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.angular_velocity)
}

// optional .rlbot.api.Vector3 acceleration = 5;
inline bool BallInfo::has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != NULL;
}
inline void BallInfo::clear_acceleration() {
  if (GetArenaNoVirtual() == NULL && acceleration_ != NULL) delete acceleration_;
  acceleration_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::acceleration() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.acceleration)
  return acceleration_ != NULL ? *acceleration_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* BallInfo::mutable_acceleration() {
  
  if (acceleration_ == NULL) {
    acceleration_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.acceleration)
  return acceleration_;
}
inline ::rlbot::api::Vector3* BallInfo::release_acceleration() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.acceleration)
  
  ::rlbot::api::Vector3* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_acceleration(::rlbot::api::Vector3* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.acceleration)
}

// optional .rlbot.api.Touch latest_touch = 6;
inline bool BallInfo::has_latest_touch() const {
  return this != internal_default_instance() && latest_touch_ != NULL;
}
inline void BallInfo::clear_latest_touch() {
  if (GetArenaNoVirtual() == NULL && latest_touch_ != NULL) delete latest_touch_;
  latest_touch_ = NULL;
}
inline const ::rlbot::api::Touch& BallInfo::latest_touch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.latest_touch)
  return latest_touch_ != NULL ? *latest_touch_
                         : *::rlbot::api::Touch::internal_default_instance();
}
inline ::rlbot::api::Touch* BallInfo::mutable_latest_touch() {
  
  if (latest_touch_ == NULL) {
    latest_touch_ = new ::rlbot::api::Touch;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.latest_touch)
  return latest_touch_;
}
inline ::rlbot::api::Touch* BallInfo::release_latest_touch() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.latest_touch)
  
  ::rlbot::api::Touch* temp = latest_touch_;
  latest_touch_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_latest_touch(::rlbot::api::Touch* latest_touch) {
  delete latest_touch_;
  latest_touch_ = latest_touch;
  if (latest_touch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.latest_touch)
}

inline const BallInfo* BallInfo::internal_default_instance() {
  return &BallInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// BoostInfo

// optional .rlbot.api.Vector3 location = 1;
inline bool BoostInfo::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void BoostInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& BoostInfo::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.location)
  return location_ != NULL ? *location_
                         : *::rlbot::api::Vector3::internal_default_instance();
}
inline ::rlbot::api::Vector3* BoostInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BoostInfo.location)
  return location_;
}
inline ::rlbot::api::Vector3* BoostInfo::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.BoostInfo.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void BoostInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BoostInfo.location)
}

// optional bool is_active = 2;
inline void BoostInfo::clear_is_active() {
  is_active_ = false;
}
inline bool BoostInfo::is_active() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.is_active)
  return is_active_;
}
inline void BoostInfo::set_is_active(bool value) {
  
  is_active_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.BoostInfo.is_active)
}

// optional float timer = 3;
inline void BoostInfo::clear_timer() {
  timer_ = 0;
}
inline float BoostInfo::timer() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.timer)
  return timer_;
}
inline void BoostInfo::set_timer(float value) {
  
  timer_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.BoostInfo.timer)
}

inline const BoostInfo* BoostInfo::internal_default_instance() {
  return &BoostInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// GameInfo

// optional float seconds_elapsed = 1;
inline void GameInfo::clear_seconds_elapsed() {
  seconds_elapsed_ = 0;
}
inline float GameInfo::seconds_elapsed() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.seconds_elapsed)
  return seconds_elapsed_;
}
inline void GameInfo::set_seconds_elapsed(float value) {
  
  seconds_elapsed_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.seconds_elapsed)
}

// optional float game_time_remaining = 2;
inline void GameInfo::clear_game_time_remaining() {
  game_time_remaining_ = 0;
}
inline float GameInfo::game_time_remaining() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.game_time_remaining)
  return game_time_remaining_;
}
inline void GameInfo::set_game_time_remaining(float value) {
  
  game_time_remaining_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.game_time_remaining)
}

// optional bool is_overtime = 3;
inline void GameInfo::clear_is_overtime() {
  is_overtime_ = false;
}
inline bool GameInfo::is_overtime() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_overtime)
  return is_overtime_;
}
inline void GameInfo::set_is_overtime(bool value) {
  
  is_overtime_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_overtime)
}

// optional bool is_unlimited_time = 4;
inline void GameInfo::clear_is_unlimited_time() {
  is_unlimited_time_ = false;
}
inline bool GameInfo::is_unlimited_time() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_unlimited_time)
  return is_unlimited_time_;
}
inline void GameInfo::set_is_unlimited_time(bool value) {
  
  is_unlimited_time_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_unlimited_time)
}

// optional bool is_round_active = 5;
inline void GameInfo::clear_is_round_active() {
  is_round_active_ = false;
}
inline bool GameInfo::is_round_active() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_round_active)
  return is_round_active_;
}
inline void GameInfo::set_is_round_active(bool value) {
  
  is_round_active_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_round_active)
}

// optional bool is_kickoff_pause = 6;
inline void GameInfo::clear_is_kickoff_pause() {
  is_kickoff_pause_ = false;
}
inline bool GameInfo::is_kickoff_pause() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_kickoff_pause)
  return is_kickoff_pause_;
}
inline void GameInfo::set_is_kickoff_pause(bool value) {
  
  is_kickoff_pause_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_kickoff_pause)
}

// optional bool is_match_ended = 7;
inline void GameInfo::clear_is_match_ended() {
  is_match_ended_ = false;
}
inline bool GameInfo::is_match_ended() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_match_ended)
  return is_match_ended_;
}
inline void GameInfo::set_is_match_ended(bool value) {
  
  is_match_ended_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_match_ended)
}

inline const GameInfo* GameInfo::internal_default_instance() {
  return &GameInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// GameTickPacket

// repeated .rlbot.api.PlayerInfo players = 1;
inline int GameTickPacket::players_size() const {
  return players_.size();
}
inline void GameTickPacket::clear_players() {
  players_.Clear();
}
inline const ::rlbot::api::PlayerInfo& GameTickPacket::players(int index) const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.players)
  return players_.Get(index);
}
inline ::rlbot::api::PlayerInfo* GameTickPacket::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.players)
  return players_.Mutable(index);
}
inline ::rlbot::api::PlayerInfo* GameTickPacket::add_players() {
  // @@protoc_insertion_point(field_add:rlbot.api.GameTickPacket.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >*
GameTickPacket::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:rlbot.api.GameTickPacket.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >&
GameTickPacket::players() const {
  // @@protoc_insertion_point(field_list:rlbot.api.GameTickPacket.players)
  return players_;
}

// optional int32 player_index = 2;
inline void GameTickPacket::clear_player_index() {
  player_index_ = 0;
}
inline ::google::protobuf::int32 GameTickPacket::player_index() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.player_index)
  return player_index_;
}
inline void GameTickPacket::set_player_index(::google::protobuf::int32 value) {
  
  player_index_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameTickPacket.player_index)
}

// repeated .rlbot.api.BoostInfo boost_pads = 3;
inline int GameTickPacket::boost_pads_size() const {
  return boost_pads_.size();
}
inline void GameTickPacket::clear_boost_pads() {
  boost_pads_.Clear();
}
inline const ::rlbot::api::BoostInfo& GameTickPacket::boost_pads(int index) const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Get(index);
}
inline ::rlbot::api::BoostInfo* GameTickPacket::mutable_boost_pads(int index) {
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Mutable(index);
}
inline ::rlbot::api::BoostInfo* GameTickPacket::add_boost_pads() {
  // @@protoc_insertion_point(field_add:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >*
GameTickPacket::mutable_boost_pads() {
  // @@protoc_insertion_point(field_mutable_list:rlbot.api.GameTickPacket.boost_pads)
  return &boost_pads_;
}
inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >&
GameTickPacket::boost_pads() const {
  // @@protoc_insertion_point(field_list:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_;
}

// optional .rlbot.api.BallInfo ball = 4;
inline bool GameTickPacket::has_ball() const {
  return this != internal_default_instance() && ball_ != NULL;
}
inline void GameTickPacket::clear_ball() {
  if (GetArenaNoVirtual() == NULL && ball_ != NULL) delete ball_;
  ball_ = NULL;
}
inline const ::rlbot::api::BallInfo& GameTickPacket::ball() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.ball)
  return ball_ != NULL ? *ball_
                         : *::rlbot::api::BallInfo::internal_default_instance();
}
inline ::rlbot::api::BallInfo* GameTickPacket::mutable_ball() {
  
  if (ball_ == NULL) {
    ball_ = new ::rlbot::api::BallInfo;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.ball)
  return ball_;
}
inline ::rlbot::api::BallInfo* GameTickPacket::release_ball() {
  // @@protoc_insertion_point(field_release:rlbot.api.GameTickPacket.ball)
  
  ::rlbot::api::BallInfo* temp = ball_;
  ball_ = NULL;
  return temp;
}
inline void GameTickPacket::set_allocated_ball(::rlbot::api::BallInfo* ball) {
  delete ball_;
  ball_ = ball;
  if (ball) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.GameTickPacket.ball)
}

// optional .rlbot.api.GameInfo game_info = 5;
inline bool GameTickPacket::has_game_info() const {
  return this != internal_default_instance() && game_info_ != NULL;
}
inline void GameTickPacket::clear_game_info() {
  if (GetArenaNoVirtual() == NULL && game_info_ != NULL) delete game_info_;
  game_info_ = NULL;
}
inline const ::rlbot::api::GameInfo& GameTickPacket::game_info() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.game_info)
  return game_info_ != NULL ? *game_info_
                         : *::rlbot::api::GameInfo::internal_default_instance();
}
inline ::rlbot::api::GameInfo* GameTickPacket::mutable_game_info() {
  
  if (game_info_ == NULL) {
    game_info_ = new ::rlbot::api::GameInfo;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.game_info)
  return game_info_;
}
inline ::rlbot::api::GameInfo* GameTickPacket::release_game_info() {
  // @@protoc_insertion_point(field_release:rlbot.api.GameTickPacket.game_info)
  
  ::rlbot::api::GameInfo* temp = game_info_;
  game_info_ = NULL;
  return temp;
}
inline void GameTickPacket::set_allocated_game_info(::rlbot::api::GameInfo* game_info) {
  delete game_info_;
  game_info_ = game_info;
  if (game_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.GameTickPacket.game_info)
}

inline const GameTickPacket* GameTickPacket::internal_default_instance() {
  return &GameTickPacket_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace rlbot

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_5fdata_2eproto__INCLUDED
